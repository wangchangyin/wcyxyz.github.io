---
layout:     post
iframe:     "http://huangxuan.me/js-module-7day/"
title:      高频面试题
subtitle:   面试题
date:       2021-04-12
author:     WangChangYin
header-img: img/post-bg-ios9-web.jpg
catalog: 	 true
tags:
   - 面试题
   - java
---

# 高频面试题

## 一.java

### 1.GC回收机制

**年轻代（Young Generation）**

　　1.所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。

　　2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。

　　3.当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收

　　4.新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)

**年老代（Old Generation）**

　　1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

　　2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。

### 2.如何判断对象是否死亡（两种方法）。

1. 引用计数法：对象被引用一次就+1，引用失效就-1,若等于0则对象死亡。
2. 可达性分析：
   1. 找出所有未被引用的对象，并放入到不可达集合中；
   2. 筛选出所有的未执行finalisize()方法或已执行一次finalisize()的对象；
   3. 若对象还是没用引用，则判断对象以及死亡。

### 3.如何判断一个常量是废弃常量

> 若常量没有被引用即是废弃常量。

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

### 4.如何判断一个类是无用的类

类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

1. 类的实例已经被回收
2. 类的classLoader已经被回收
3. 类的`java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 5.垃圾收集有哪些算法，各自的特点？

1. 标记-清除：标记所有的不需要回收的对象，清除所有的未标记对象；

   缺点：空间利用率低

   ![img](..\assets\image\高频面试_img\标记-清除算法.jpeg)

2. 标记-复制:标记所有的不需要回收对象，把内存空间分为两部分，清除回收对象，把不需要回收对象复制到另一边。

   ![img](..\assets\image\高频面试_img\90984624.png)

3. 标记-整理:标记所有的不需要回收对象，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

   ![img](..\assets\image\高频面试_img\94057049.png)

4. 分代收集算法：（新生区(Eden、from 、to)、老生区)

   当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

   **比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

### 6.常见的垃圾回收器有哪些？

1. 串行(Serial)收集器：停止所有工作流程进行垃圾回收(单线程)

2. 并行收集器:停止所有工作流程进行垃圾回收(多线程)

3. CMS收集器:垃圾回收和用户线程同时进行；

   CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

   - **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
   - **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
   - **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
   - **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

   从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

   - **对 CPU 资源敏感；**
   - **无法处理浮动垃圾；**
   - **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

4. G1收集器：

   它具备以下特点：

   - **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
   - **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
   - **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
   - **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

   G1 收集器的运作大致分为以下几个步骤：

   - **初始标记**
   - **并发标记**
   - **最终标记**
   - **筛选回收**

   **G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

### 7.sleep和wait的区别

- sleep属于Thread类，wait属于Object类
- sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态；线程不会释放对象锁。
- 调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。

![在这里插入图片描述](.\高频面试_img\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDA5MDE1,size_16,color_FFFFFF,t_70)

### 8.Synchronized的原理

jdk1.6之前：**直接使用重量锁，需要借助操作系统，直接从用户态切换为内核态，耗资源**

jdk1.6之后：

Synchronized减重的过程，通常被称为锁膨胀或是锁升级的过程。
主要步骤是：

- 先是通过**偏向锁**来获取锁，解决了虽然有同步但无竞争的场景下锁的消耗。

  若当前线程之前获得过锁，就会优先获取锁，内部维护了一个变量，每次获得锁+1

- 再是通过对象头的Mark Word来实现的轻量级锁，通过**轻量级锁（CAS）**如果还有竞争，那么继续升级。

- 升级为**自旋锁**，如果达到最大自旋次数了，那么就直接升级为重量级锁，所有未获取锁的线程都阻塞等待。

  当一个线程请求被锁住的对象，让该线程等待一会

------

## 二.数据结构

------

## 三.网络

------

## 四.操作系统

### 1.进程与线程的区别：

看了一遍排在前面的答案，类似”**进程是资源分配的最小单位，线程是CPU调度的最小单位“**这样的回答感觉太抽象，都不太容易让人理解。

做个简单的比喻：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

### 2.进程调度

1. 先来先服务调度算法：先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。
2. 短作业(进程)优先调度算法：短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。
3. 高优先权优先调度算法：为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。

------

## 五.Mysql

### 1.聚集索引和非聚集索引

**聚集索引**

通常由主键表示，打个比方，一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址，我们如果要查询一个“哇”字，我们只需要查询“哇”字对应在新华字典拼音目录对应的页码，就可以查询到对应的“哇”字所在的位置，而拼音目录对应的A-Z的字顺序，和新华字典实际存储的字的顺序A-Z也是一样的，如果我们中文新出了一个字，拼音开头第一个是B，那么他插入的时候也要按照拼音目录顺序插入到A字的后面，

**非聚集（unclustered）索引。**

> 定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。

其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。

### 2.分页查找优化

1. 分表、加索引
2. 在分页之前加条件，比如SELECT * FROM your_table WHERE pk>=1000 ORDER BY pk ASC LIMIT 0,20
3. 查询数据只查询主键数据，贼快
4. **如果我们也要查询所有列，有两种方法，一种是id>=的形式，另一种就是利用join，看下实际情况：**

> SELECT * FROM product WHERE ID > =(select id from product limit 866613, 1) limit 20

> SELECT * FROM product a JOIN (select id from product limit 866613, 20) b ON a.ID = b.id

### 3.为什么mysql索引要使用B+树，而不是B树，红黑树

**由于B树的所有节点都存储了数据，而B+树只有叶子节点存储数据，并且叶子节点还存储了下节点的指针，数据库中会存在范围查找，如果用B树那么只能每次一个一个的去查找；而B+树查找到后，通过指针可以找到区间内的数据。**

参考：https://www.cnblogs.com/leijiangtao/p/4662779.html

树的深度决定了IO操作的次数

1. B树应用

   主要用于文件系统以及部分数据库索引（[MongoDB](https://cloud.tencent.com/product/mongodb?from=10680)） 而Mysql是用B+树的。

2. B+树

> B+树的最大元素始终位于根节点当中。所有叶子节点包含了全量元素信息，并且每一个叶子节点都带有指向 下一个节点指针，形成了一个有序链表。
>
> <img src="https://segmentfault.com/img/remote/1460000021488901" alt="img" style="zoom:200%;" />

B树和B+树的区别：

1.单一节点存储更多的元素，使得查询的IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。

------

## 六.redis

### 1. redis为什么采用跳表而不是红黑树？？

> 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
> 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
> 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
> 查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。
> 从算法实现难度上来比较，skiplist比平衡树要简单得多。
